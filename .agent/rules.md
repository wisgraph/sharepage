# 리팩토링 가이드라인 2.0: 예측 가능한 코드 (AI-Friendly Code)

## 🎯 핵심 철학

> **"예측 불가능한 코드는 오해의 근본 원인이다."**
>
> 함수명은 약속이다. 함수명과 실제 동작의 괴리(Gap)가 클수록, AI와 개발자는 코드를 오해하고 버그를 양산한다.

---

## 🔍 예측 가능성(Predictability)이란?

**정의**: 
AI(또는 동료 개발자)에게 **"함수명(Signature)만 보여주고 내부 구현을 상상하게 했을 때"**, 상상한 코드와 실제 코드가 일치하는 정도.

### CQS (Command-Query Separation) 심화
- **Query (질문)**: 값을 반환하며, **관찰 가능한 상태(Externally Observable State)**를 변경하지 않는다.
  - *허용 범위*: `memoization`, `read-through cache`, `lazy loading`, 비침투적 `logging`. (호출자 입장에서 결과가 항상 같다면 내부 캐싱은 허용)
- **Command (명령)**: 시스템의 상태를 영구적으로 변경하며, 값을 반환하지 않는다.
- **규칙**: **Query 함수가 호출자가 인지할 수 있는 시스템 상태(DB, 전역변수 등)를 몰래 변경하면 '사기꾼(⭐)'이다.**

---

## 🌟 예측 가능성 평가 기준 (AI 에이전트용)

"거짓말을 하지 않는가?"를 기준으로 하며, AI 에이전트가 자동 평가할 수 있는 지표를 포함한다.

| 별점 | 등급 | 상태 설명 | AI/Linter 자동 평가 기준 |
|:---:|:---:|---|---|
| ⭐ | **최악** | **"사기꾼"**<br>Query인 척하며 Command 수행 (CQS 위반) | `return`이 있는 함수 내부에서 `INSERT/UPDATE/DELETE` 구문 발견. |
| ⭐⭐ | **나쁨** | **"과장/축소 광고"**<br>함수명에 없는 중요 부수 효과 존재 | 반환 타입이 `void`인데 함수명에 명시되지 않은 상태 변경 로직 존재. |
| ⭐⭐⭐ | **보통** | **"애매모호"**<br>너무 포괄적인 네이밍 | 함수명에 동사가 2개 이상(`getAndSave`)이거나, 범용 동사(`do`, `process`) 단독 사용. |
| ⭐⭐⭐⭐ | **좋음** | **"정직함"**<br>대부분의 로직이 이름에서 유추 가능 | 함수명이 `동사+목적어` 형태이며, 내부 로직이 그 범위 내에 있음. |
| ⭐⭐⭐⭐⭐ | **완벽** | **"투명함"**<br>이름이 곧 구현이며 부작용 없음 | 순수 함수(Pure Function)에 가깝거나, 명백한 단일 책임만 수행. |

---

## ⚠️ 경고 신호 (Red Flags)

### 1. 인지 부하 과다 (High Cognitive Load)
- **물리적 길이**: 100줄 이상 (God Function).
- **논리적 깊이**: **들여쓰기(Indent) 3단계 이상**.
- *이유*: 인간과 AI의 작업 기억(Working Memory) 용량을 초과하여 문맥을 놓치게 만듦.
- **조치**: 즉시 상세 분석 및 분리 대상.

### 2. 접속사가 필요한 함수명
- 함수명을 짓는데 `And`, `With`, `Also`가 필수적이라면?
- 예: `validateAndSaveUser()` → **단일 책임 원칙(SRP) 위반**.

---

## 🛡️ 안전 제 1원칙 (Safety First)

> **"보호 장비 없이 폭탄을 해체하지 마라."**

### 1. 테스트 확보 (Golden Master 전략)
- **원칙**: 테스트 없는 리팩토링 금지.
- **현실적 대안**: 단위 테스트 작성이 불가능한 레거시 코드라면?
  1. **Golden Master**: 현재 코드의 입출력 스냅샷을 찍어 파일로 저장.
  2. **Refactoring**: 수정 후 스냅샷과 100% 일치하는지 비교.
  3. **Commit**: 동작 불변을 보장한 뒤 커밋.

### 2. 기계적 분리 금지 (Anti-Pattern: Ravioli Code)
- 단순히 줄 수를 줄이기 위해 맥락 없이 코드를 잘라내지 마라.
- **응집도(Cohesion)가 기준이다.**
- **Bad**: `part1()`, `part2()` (내용을 알 수 없는 파편화)
- **Good**: 도메인 의미 단위로 분리 (`calculateTax()`, `applyDiscount()`)

---

## 🛠 네이밍 가이드: 문맥과 도메인

### 1. 추상화 수준 맞추기 (SLAP)
- 함수 내의 모든 코드는 동일한 추상화 레벨이어야 한다. (비즈니스 로직과 for 루프가 섞이지 않도록)

### 2. 레이어별 금지어 (Contextual Ban List)
네이밍 규칙은 코드가 위치한 **Layer**에 따라 달라진다.

- **Core Domain (비즈니스 로직)**: **엄격 금지**
  - `process`, `handle`, `manage`, `check`
  - *이유*: 비즈니스 의도가 모호해짐. 구체적인 동작(`calculate`, `validate`, `persist`)을 써야 함.
- **Boundary / Infrastructure (웹, DB 어댑터)**: **허용**
  - `handleHttpRequest`, `processQueueMessage`
  - *이유*: 프레임워크나 인프라 관례상 필요한 경우가 많음.

### 3. 도메인 언어 우선 (Ubiquitous Language)
- 기술적 정확성보다 **도메인 의미 전달**이 우선이다.
- **Bad**: `updateUserStatusToInactive()` (기술적 서술)
- **Good**: `banUser()` (비즈니스 행위)
- **원칙**: 기획서나 현업에서 쓰는 용어를 코드에 그대로 박제하라.

---

## 📜 작업 절차 (Workflow)

1. **탐지**: Indent 3-depth 이상 or CQS 위반 의심 코드 발견.
2. **안전**: 테스트 코드 또는 Golden Master 스냅샷 확보.
3. **분석**:
   - CQS 위반 여부 체크 (관찰 가능한 상태 변경이 있는가?)
   - 도메인 언어 적합성 체크.
4. **분리**: SLAP 원칙에 따라 의미 단위로 함수 추출.
5. **검증**: 테스트 통과 확인.

---

## 🌐 언어 및 문서 규칙 (Language & Documentation)

- **원칙**: 모든 태스크(`task.md`)와 구현 계획(`implementation_plan.md`)은 **한글**로 작성합니다. 
- **이유**: 사용자와의 명확한 의사소통과 정신 모델의 일치를 위함입니다.
- **적용**: `task.md`, `implementation_plan.md`, `walkthrough.md` 등 모든 아티팩트 문서에 적용됩니다.


